# 网格数据结构的数组化表示： edge

本文将介绍如何用**数组化(array-oriented)**的思考和编程方式构造网格数据结构中的 `edge` 数组。

所谓**数组化**， 就是从已知或者简单的数组出发， 利用数组的操作和运算， 获得目标数组的过程。 与其对应的就是**标量化**的方式， 它是很多人常用到且更习惯的方式。 注意本文提到的**数组**指的是**一般的多维数组**。 而我们常用的**向量**这个词， 在数学的语境下通常是指**一维数组**， 所以为了避免语言对思维的限制， 在以后的文章中我会尽量不使用**向量化**这个词。

数组化的编程需要数组化的思维习惯。 要养成数组化的思维习惯， 当你面对一个编程问题时， 首先要养成问自己三个问题的习惯：

1. 我想获得的目标数组是什么？
2. 我手头有什么已知的数组？
3. 我需要生成什么样的中间的数组？

还是以 $[0, 1]^2$ 区域上的网格为例， 见下图：

![](./figures/twotri.png)

```
import numpy as np
# 网格节点数组
node = np.array([[0.0, 0.0],
                 [1.0, 0.0],
                 [1.0, 1.0],
                 [0.0, 1.0]], dtype=np.float)
# 网格单元数组
cell = np.array([[1, 2, 0],
                 [3, 0, 2]], dtype=np.int32)
NN = node.shape[0] # 网格中的节点个数
NC = cell.shape[0] # 网格中的单元个数
```   
**注意**， 上面的 `node`, `cell`, `NN` 和 `NC` 在以后的文章和程序表示意义都是固定的。 进一步， 我用 `edge` 表示网格边数组， 用 `NE` 表示网格中边的个数。 记住这个约定， 可以帮助你更好的理解我的文章和程序代码。 后面我会专门写一篇文章讲这些命名的约定。

对于第 1 个问题， 观察图中网格共有 5 条边， 每条边 2 个顶点， 而且可以分为两类：

* **内部边**， 被两个三角形单元共用的边。
* **边界边**， 只属于一个三角形单元。

下面定义清楚目标数组 `edge`， 并做一些适当的假定：
* `edge` 形状应为 `(NE, 2)`, 存储 NE 条**不重复的**边， 每条边有 2 个顶点。
* `edge[i, 0]` 和 `edge[i, 1]` 分别存储第 `i` 条边两个顶点的全局编号， 即 **`node` 数组的行号**。
* 如果第 `i` 条边是一条边界边， 则从`edge[i, 0]` 看向 `edge[i, 1]` 的左手边是区域内部。

对于第 2 个问题， 显然 `cell` 数组中已经包含了所有边的信息， 只要从它出发就可以提取出目标数组 `edge`。

对于第 3 个问题， 即需要什么样的中间数组？ 容易想到， 要首先把每个三角形单元的 3 条边提取出来。 当然这里存在一个边的局部编号的问题。 给定一个三角形单元， 可以通过定义一个 `localEdge` 数组来定义每个单元的局部边：

```
localEdge = np.array([[1, 2],
                      [2, 0],
                      [0, 1]], dtype=np.int32)
```
上面生成的 `localEdge` 用下面的约定构造：

* 与单元局部第 `i` 个顶点相对的局部边局部编号设为 `i, 0<=i<3`。
* 每条局部边的的左手边是**单元的内部**。

当然上面关于局部边的约定不是强制的， 你可根据需要给出自己的约定。

有了上面的 `localEdge`， 就可以把网格中所有单元的三个边都拿出来组成一个新的数组 `totalEdge`
```
totalEdge = cell[:, localEdge] # shape 为 (NC, 3, 2)
totalEdge = totalEdge.reshape(-1, 2) # shape 变为 (3*NC, 2)
```
`ndarray` 对象的 `reshape` 成员函数可以改变数组的形状， 其中第 0 个参数 `-1`， 表示让 `reshape` 自己计算新数组的第 `0` 轴的长度。 最后的 `totalEdge` 数组， 就是把每个三角形单元的三条局部边先按单元顺序， 再按局部顺序存储的形状为 `(3*NC, 2)` 的二维数组。

这时 `totalEdge` 中已经包含 `edge` 数组需要的所有信息， 但是有重复的边。 内部边会在 `totalEdge` 出现两次， 但注意两条边的方向是不一样的， 即两个顶点的排序刚好相反。 我们需要把重复的边去掉。 这里要用到 `np.unique` 函数， 用法如下：

```
totalEdge0 = totalEdge.sort(axis=1)
edge0, i0, j = np.unique(totalEdge0, return_index=True, return_inverse=True, axis=0)
```
其中 `totalEdge0 = totalEdge.sort(axis=1)` 是把 `totalEdge` 每一行的两个值重新排序， 默认从小到大。 这样重复边的两个顶点编号排序就一样了。 下面解释 `np.unique` 的用法：

* 第 0 个参数为边顶点排序后的所有局部边数组 `totalEdge0`
* 第 1 个参数 `return_index` 设为 `True`， 目的是为了返回 `i0`。
* 第 2 个参数 `return_inverse` 设为 `True`， 目的是为了返回 `j`。
* `edge0` 就是没有重复的边数组， 它和 `totalEdge0` 满足如下关系：
  + `edge0 == totalEdge0[i0]`
  + `totalEdge0 == edge0[j]`

**注意**， 上面的 `totalEdge0[i0]` 和  `edge[j]` 是指索引两个数组行， 即第 0 轴， 后面的轴可以省略不写。 这和 Matlab 索引语法是不同的。

但 `edge0` 数组并不是最终的边数组， 因为它不能保证满足前面对边数组存储的约定， 特别是**边界边左手边是区域内部**的约定。 实际上， 我们可以利用**没有做边顶点排序**的 `totalEdge` 数组及 `i0` 数组来得到最终的边数组：

```
edge = totalEdge[i0]
```

## 关系数组： cell2edge 和 edge2cell

网格中节点、边和单元之间的拓扑关系有有限元编程中也经常用到， 因此我们也需要生成这些数组。 上面生成 `edge` 数组的过程中得到的 `i0` 和 `j` 实际上已经包含了边与单元之间的拓扑关系， 下面介绍如何生成 `cell2edge` 和 `edge2cell` 数组。

首先， 先定义好这两个数组：

* `cell2edge` 的形状为 `(NC, 3)`， 其第 `i` 行 `cell2edge[i, 0]`, `cell2edge[i, 1]` 和 `cell2edge[i, 2]` 分别存储第 `i` 个单元三个局部边的全局编号， 即在 `edge` 数组中的行号。
* `edge2cell` 的形状为 `(NE, 4)`, 其中第 `i` 行 `edge2cell[i, 0]` 和 `edge2cell[i, 1]` 存储第 `i`

利用 `j`, 还可以得到另外一个一维数组 `i1`， 它和 `i0` 的长度是一样的， 而且也使得 `edge0 == totalEdge0[i1, :]`。 与 `i0` 的不同之处在于， 对于第 `i` 条边 `edge0[i, :]`：

* 如果是内部边， 则 `i0[i] != i1[i]`， 它们是同一条内部边在 `totalEdge0` 中出现两次的行号。
* 如果是边界边， 则 `i0[i] == i1[i]`， 它们是同一条边界边在 `totalEdge0` 中出现一次的行号。

下面代码给出用 `j`， 得到 `i0` 的方法

```
E = 3 # 每个三角形有 3 条边
NE = len(i0) # 获得网格中边的个数
i1 = np.zeros(NE, dtype=self.itype) # 分配空间
i1[j] = range(3*NC) # totalEdge0 的行数是 3*NC, j 的长度也是 3*NC
```
上面的最后一行代码中， `i1` 数组的第 `i` 个位置会赋值 1 次（边界边）或者 2 次（内部边）。 内部边第 2 次赋值时， 就把第 1 次的赋值覆盖了， 从而达到得到内部边在 `totalEdge0` 中另一个行号的目的。



```
edge2cell = np.zeros((NE, 4), dtype=np.int32)
edge2cell[:, 0] = i0//E
edge2cell[:, 1] = i1//E
edge2cell[:, 2] = i0%E
edge2cell[:, 3] = i1%E
```
